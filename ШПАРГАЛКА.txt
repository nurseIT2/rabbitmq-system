═══════════════════════════════════════════════════════════════
    ШПАРГАЛКА ДЛЯ ЗАЩИТЫ ПРОЕКТА - RabbitMQ Messaging System
═══════════════════════════════════════════════════════════════

📌 ЧТО Я СДЕЛАЛ:
─────────────────────────────────────────────────────────────
Создал систему обмена сообщениями между двумя микросервисами:
1. Order Service - создаёт заказы и отправляет в RabbitMQ
2. Notification Service - получает заказы из RabbitMQ

─────────────────────────────────────────────────────────────
📌 ОСНОВНЫЕ КОМПОНЕНТЫ:
─────────────────────────────────────────────────────────────

Order Service (Порт 8080) - ПРОСТАЯ СТРУКТУРА:
  📁 order-service/rabbitmq/orderservice/
     • OrderServiceApplication.java - главный класс
     • OrderController.java - принимает HTTP запросы
     • OrderPublisher.java - отправляет в RabbitMQ  
     • OrderDTO.java - данные заказа
     • application.properties - настройки

Notification Service (Порт 8081) - ПРОСТАЯ СТРУКТУРА:
  📁 notification-service/rabbitmq/notificationservice/
     • NotificationServiceApplication.java - главный класс
     • OrderNotificationListener.java - слушает RabbitMQ
     • OrderDTO.java - данные заказа
     • application.properties - настройки

RabbitMQ:
  • Exchange: order-topic-exchange (Topic тип)
  • Очереди: almaty_orders_queue, astana_orders_queue, common_orders_queue
  • Routing Keys: order.almaty, order.astana, order.#

─────────────────────────────────────────────────────────────
📌 УСТАНОВКА MAVEN (если команда mvn не найдена):
─────────────────────────────────────────────────────────────

1. Установить Homebrew (если еще нет):
   /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

2. Установить Maven:
   brew install maven

3. Проверить установку:
   mvn -version

─────────────────────────────────────────────────────────────
📌 КОМАНДЫ ДЛЯ ЗАПУСКА (запомнить!):
─────────────────────────────────────────────────────────────

Терминал 1 - RabbitMQ:
  cd /Users/nurseit.shukenovapple.kz/Desktop/rabbitmq-system
  docker-compose up

Терминал 2 - Notification Service:
  cd /Users/nurseit.shukenovapple.kz/Desktop/rabbitmq-system/notification-service
  mvn spring-boot:run

Терминал 3 - Order Service:
  cd /Users/nurseit.shukenovapple.kz/Desktop/rabbitmq-system/order-service
  mvn spring-boot:run

Терминал 4 - Тестирование:
  curl -X POST http://localhost:8080/order/almaty \
    -H "Content-Type: application/json" \
    -d '{"restaurant": "KFC", "courier": "Иван", "foods": ["Пицца"], "status": "Новый"}'

─────────────────────────────────────────────────────────────
📌 ВОПРОСЫ ПРЕПОДАВАТЕЛЯ - ГОТОВЫЕ ОТВЕТЫ:
─────────────────────────────────────────────────────────────

❓ Что такое RabbitMQ?
✅ Это брокер сообщений для асинхронного обмена данными между 
   микросервисами. Позволяет сервисам общаться без прямого 
   соединения.

❓ Зачем нужен RabbitMQ, а не просто HTTP?
✅ - Асинхронность (сервисы не ждут друг друга)
   - Надёжность (сообщения сохраняются в очереди)
   - Масштабируемость (легко добавить новые сервисы)

❓ Что такое Topic Exchange?
✅ Это тип обменника в RabbitMQ, который маршрутизирует сообщения 
   по routing key (как DNS маршрутизирует по доменным именам).

❓ Что означает routing key "order.#"?
✅ Это wildcard паттерн. Символ # означает "любые слова".
   order.# ловит ВСЕ сообщения, начинающиеся с "order."
   Например: order.almaty, order.astana, order.shymkent

❓ Зачем нужны очереди?
✅ Очереди хранят сообщения до тех пор, пока их не обработает 
   получатель. Если сервис упал, сообщения не потеряются.

❓ Почему два сервиса, а не один?
✅ Микросервисная архитектура - разделение ответственности:
   - Order Service отвечает только за создание заказов
   - Notification Service только за уведомления
   Каждый сервис можно масштабировать и развивать отдельно.

❓ Что такое @RabbitListener?
✅ Аннотация Spring, которая автоматически подписывает метод 
   на получение сообщений из RabbitMQ. Когда приходит сообщение,
   Spring вызывает этот метод.

❓ Зачем Lombok?
✅ Библиотека для автоматической генерации кода (геттеры, 
   сеттеры, конструкторы). @Data создаёт их автоматически.

❓ Что делает RabbitTemplate?
✅ Это Spring компонент для отправки сообщений в RabbitMQ.
   Метод convertAndSend() отправляет объект в очередь.

❓ Покажи как работает система?
✅ 1. Клиент отправляет POST на /order/almaty
   2. OrderController принимает запрос
   3. OrderPublisher отправляет в RabbitMQ с ключом "order.almaty"
   4. Exchange маршрутизирует в очереди almaty_orders_queue и common_orders_queue
   5. OrderNotificationListener получает и выводит в консоль

─────────────────────────────────────────────────────────────
📌 ТЕХНОЛОГИИ (что использовал):
─────────────────────────────────────────────────────────────
• Java 17
• Spring Boot 3.1.5 (фреймворк)
• Spring AMQP (интеграция с RabbitMQ)
• RabbitMQ (брокер сообщений)
• Docker (запуск RabbitMQ)
• Maven (сборка проекта)
• Lombok (упрощение кода)

─────────────────────────────────────────────────────────────
📌 ГДЕ В КОДЕ ПОКАЗАТЬ РЕАЛИЗАЦИЮ ТЕМЫ:
─────────────────────────────────────────────────────────────

🎯 ТЕМА: "Маршрутизация сообщений по регионам через Topic Exchange"

1️⃣ МАРШРУТИЗАЦИЯ ПО РЕГИОНУ (OrderPublisher.java):
   📁 order-service/rabbitmq/orderservice/OrderPublisher.java
   
   Строка 17-20:
   public void sendOrder(OrderDTO order, String region) {
       String routingKey = "order." + region;  // ← ЗДЕСЬ!
       rabbitTemplate.convertAndSend(topicExchange, routingKey, order);
   }
   
   💬 ЧТО СКАЗАТЬ:
   "Здесь реализована маршрутизация по регионам. Метод принимает
   регион и создаёт routing key вида 'order.almaty'. Это ключевая
   часть темы - каждый регион получает свой уникальный routing key."

2️⃣ ПРИЕМ ДЛЯ КОНКРЕТНОГО РЕГИОНА (OrderNotificationListener.java):
   📁 notification-service/rabbitmq/notificationservice/OrderNotificationListener.java
   
   Строки 14-19:
   @RabbitListener(bindings = @QueueBinding(
       value = @Queue(value = "almaty_orders_queue"),
       exchange = @Exchange(value = "${mq.order.topic.exchange}",
                           type = ExchangeTypes.TOPIC),  // ← TOPIC!
       key = "order.almaty"))  // ← ROUTING KEY ДЛЯ ALMATY!
   
   💬 ЧТО СКАЗАТЬ:
   "Этот listener подписан на конкретный регион через routing key
   'order.almaty'. Topic Exchange позволяет фильтровать сообщения
   по шаблонам - это основа региональной маршрутизации."

3️⃣ ПРИЕМ ДЛЯ ВСЕХ РЕГИОНОВ (OrderNotificationListener.java):
   📁 notification-service/rabbitmq/notificationservice/OrderNotificationListener.java
   
   Строки 30-35:
   @RabbitListener(bindings = @QueueBinding(
       value = @Queue(value = "common_orders_queue"),
       exchange = @Exchange(value = "${mq.order.topic.exchange}",
                           type = ExchangeTypes.TOPIC),
       key = "order.#"))  // ← WILDCARD! ВСЕ РЕГИОНЫ!
   
   💬 ЧТО СКАЗАТЬ:
   "Wildcard 'order.#' ловит ВСЕ регионы. Это демонстрирует гибкость
   Topic Exchange - один listener может обрабатывать все регионы,
   а другие - только конкретные."

4️⃣ REST API С РЕГИОНОМ (OrderController.java):
   📁 order-service/rabbitmq/orderservice/OrderController.java
   
   Строки 13-17:
   @PostMapping("/{region}")  // ← РЕГИОН В URL!
   public ResponseEntity<String> createOrder(
           @PathVariable String region,  // ← ПОЛУЧАЕМ РЕГИОН
           @RequestBody OrderDTO order) {
       publisher.sendOrder(order, region);  // ← ПЕРЕДАЁМ
   
   💬 ЧТО СКАЗАТЬ:
   "REST endpoint принимает регион как параметр URL. Например,
   /order/almaty или /order/astana. Это точка входа для
   региональной маршрутизации."

─────────────────────────────────────────────────────────────
📌 СХЕМА ДЛЯ ОБЪЯСНЕНИЯ:
─────────────────────────────────────────────────────────────

1. POST /order/almaty → OrderController
2. region="almaty" → OrderPublisher
3. routingKey="order.almaty" → Topic Exchange
4. Exchange маршрутизирует:
   - "order.almaty" → almaty_orders_queue
   - "order.#" → common_orders_queue
5. Listeners получают и логируют

─────────────────────────────────────────────────────────────
📌 ЧТО ПОКАЗАТЬ НА ЗАЩИТЕ:
─────────────────────────────────────────────────────────────

1. Запустить все 3 компонента (RabbitMQ, оба сервиса)
2. Открыть http://localhost:15672 - показать RabbitMQ UI
3. Отправить тестовый заказ через curl
4. Показать в консоли Notification Service, что пришло 2 сообщения:
   - "Received Almaty order: ..."
   - "Received (common listener) order: ..."
5. Объяснить: "Заказ попал в 2 очереди, потому что routing key 
   order.almaty подходит и под конкретный listener (almaty), 
   и под общий (order.#)"

─────────────────────────────────────────────────────────────
📌 ВОЗМОЖНЫЕ УСЛОЖНЕНИЯ (если попросят):
─────────────────────────────────────────────────────────────

"Добавь новый регион":
  - Просто отправь POST на /order/karaganda
  - Сообщение обработает common listener автоматически!
  
"Добавь специальный обработчик для региона":
  - Скопируй метод handleAlmatyOrder() 
  - Поменяй название и routing key на новый регион

─────────────────────────────────────────────────────────────
📌 ВАЖНО ЗАПОМНИТЬ:
─────────────────────────────────────────────────────────────
• Order Service на порту 8080
• Notification Service на порту 8081
• RabbitMQ UI на http://localhost:15672 (guest/guest)
• Три очереди создаются автоматически при первом запуске
• order.# означает "все сообщения с order."

═══════════════════════════════════════════════════════════════
           УДАЧИ НА ЗАЩИТЕ! ВСЁ ПОЛУЧИТСЯ! 🚀
═══════════════════════════════════════════════════════════════
